// replace the first space of the char by a null character, and return a
// pointer to the part after the null character that was added
char* parseline(char* line) {
    int i;
    for (i = 0; line[i] != ' ' && line[i] != '\0'; i=i+1)
    {}

    if (line[i] == '\0') {
        return (char*)((int)line + i);
    }
    line[i] = '\0';
    return (char*)((int)line + i + 1);
}

void load_command() {
    int i;

    // read size (in 32 bits words)
    int size = getint();

    // read file word per word
    int* file = (int*)malloc(size);

    for(i = 0; i < size; i=i+1) {
        *(file + i) = getint();
    }

    // write address to user
    char[12] addr_hex;
    dtoa((int)file, addr_hex);
    write("File loaded at address ");
    write(addr_hex);
    putc('\n');
}

void shell(char* line) {
    char* parameters = parseline(line);

    if (line[0] == (char)3 /* ^C */ || strcmp(line, "quit")) {
        putc((char)4); // ^D
        putc('\n');
    }
    else if (strcmp(line, "echo")) {
        write(parameters);
        putc('\n');
    }
    else if (strcmp(line, "help")) {
        write("Commands: help, echo, run, kill, load.\n");
    }
    else if(strcmp(line, "run")) {
        if(strcmp(parameters, "dummy")) {
            start_process(task_dummy);
        }
        else if(strcmp(parameters, "leds")) {
            start_process(task_leds);
        }
        else if(strcmp(parameters, "counter")) {
            start_process(task_counter);
        }
        else {
            write("Usage: run dummy|leds|counter\n");
        }
    }
    else if(strcmp(line, "kill")) {
        if(parameters[1] == '\0') {
            int pid = (int)parameters[0] - (int)'0';
            kill_process(pid);
        }
        else {
            write("Usage: kill pid\n");
        }
    }
    else if(strcmp(line, "load")) {
        load_command();
    }
    else {
        write("Unknown command, try help.\n");
    }
}
