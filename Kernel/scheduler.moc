// every N PWM-interruptions we do a context switch, this is the counter
int pwm_count;

#define NB_SAVED_REGISTERS 23

// implementation of the context switch
asm("
pwm_handler:
    push %r1
    push %r24 // code position (for globals)
    setq 0, %r24

    ld $pwm_count, %r1
    inccc %r1

    // do we do a context switch, or nothing ?
    cmp %r1, 100
    bge pwm_handler_do_it

    st %r1, $pwm_count
    pop %r24
    pop %r1
    reti

    ////////////////////
    // context switch //
    ////////////////////

pwm_handler_do_it:
    st %r0, $pwm_count

    push %r2
    push %r3
    push %r4
    push %r5
    push %r6
    push %r7
    push %r8
    push %r9
    push %r10
    push %r11
    push %r12
    push %r13
    push %r14
    push %r15
    push %r16
    push %r17
    push %r18
    push %r19
    push %fp
    push %r28 // @ret

    ld $process_table, %r2
    ld [%r2], %r4 // %r4: current_task
    add %r2, %r4, %r5 // %r5: current task entry
    inccc %r5

    // store the stack pointer
    ld [%r5], %r6
    cmp %r6, %r0
    beq pwm_handler_ctloop
    st %sp, [%r5]

    // now it is stored, we can load the other task

pwm_handler_ctloop:
    // current_task = (current_task + 1) % nb_tasks
    inccc %r4
    cmp %r4, PROCESS_COUNT
    bl pwm_handler_afterreset
    mov %r0, %r4
pwm_handler_afterreset:

    add %r2, %r4, %r5 // %r5: current task entry
    inccc %r5
    ld [%r5], %sp

    cmp %sp, %r0
    beq pwm_handler_ctloop

    st %r4, [%r2]

    pop %r28 // @ret
    pop %fp
    pop %r19
    pop %r18
    pop %r17
    pop %r16
    pop %r15
    pop %r14
    pop %r13
    pop %r12
    pop %r11
    pop %r10
    pop %r9
    pop %r8
    pop %r7
    pop %r6
    pop %r5
    pop %r4
    pop %r3
    pop %r2
    pop %r24 // code pos
    pop %r1
    reti
")

void kill_process(int pid) {
    asm("
    setq 2, %r1
    ld $pid, %r2
    syscall");
}

void start_process(void* start_addr) {
    asm("
    setq 1, %r1
    ld $start_addr, %r2
    syscall");
}

void _kill_process(int pid) {
    if(pid >= PROCESS_COUNT) {
        _panic(5);
    }

    if(_free_pid(pid) == -1) {
        _panic(6);
    }

    *((int*)process_table.stack_pointers + pid) = 0;
}

void _start_process(void* start_addr) {
    int i = 0;
    while(*((bool*)process_table.stack_pointers + i)){
        i = i + 1;
    }

    if(i >= PROCESS_COUNT) {
        _panic(1); // no PID/slot available
    }

    // we change the current process just for malloc to have it.
    int cp = process_table.current_process;
    process_table.current_process = i;

    void* stack = _malloc(256) + 255;

    process_table.current_process = cp;

    // as a convention, we put on the stack the address of the first
    // instruction of the task (for "bootstraping" the processes)
    *((int*) stack) = (int)start_addr;

    int j;
    for(j=0; j < NB_SAVED_REGISTERS; j=j+1) {
        stack = stack - 1;
        *((int*) stack) = 0;
    }

    *((void**)process_table.stack_pointers + i) = stack;
}

