// every N PWM-interruptions we do a context switch, this is the counter
int pwm_count;

#define NB_SAVED_REGISTERS 23

// implementation of the context switch
asm("
pwm_handler:
    push %r1
    push %r24 // code position (for globals)
    setq 0, %r24

    ld $pwm_count, %r1
    inccc %r1

    // do we do a context switch, or nothing ?
    cmp %r1, 100
    bge pwm_handler_do_it

    st %r1, $pwm_count
    pop %r24
    pop %r1
    reti

    ////////////////////
    // context switch //
    ////////////////////

pwm_handler_do_it:
    st %r0, $pwm_count

    push %r2
    push %r3
    push %r4
    push %r5
    push %r6
    push %r7
    push %r8
    push %r9
    push %r10
    push %r11
    push %r12
    push %r13
    push %r14
    push %r15
    push %r16
    push %r17
    push %r18
    push %r19
    push %fp
    push %r28 // @ret

    mov %sp, %r1
    push %r1
    push %r28
    call f_next_stack
    pop %r28
    add %sp, 1, %sp
    mov %r1, %sp

    pop %r28 // @ret
    pop %fp
    pop %r19
    pop %r18
    pop %r17
    pop %r16
    pop %r15
    pop %r14
    pop %r13
    pop %r12
    pop %r11
    pop %r10
    pop %r9
    pop %r8
    pop %r7
    pop %r6
    pop %r5
    pop %r4
    pop %r3
    pop %r2
    pop %r24 // code pos
    pop %r1
    reti
")

export void* next_stack(void* current_stack) {
    void*[] stack_pointers = process_table.stack_pointers;

    if(stack_pointers[process_table.current_process] != NULL) {
        stack_pointers[process_table.current_process] = current_stack;
    }

    int i = process_table.current_process + 1;
    if (i == PROCESS_COUNT) {
        i = 0;
    }

    while(stack_pointers[i] == NULL) {
        i = i + 1;
        if (i == PROCESS_COUNT) {
            i = 0;
        }
    }

    process_table.current_process = i;
    return stack_pointers[i];
}

void kill_process(int pid) {
    asm("
    setq 2, %r1
    ld $pid, %r2
    syscall");
}

void start_process(void* start_addr) {
    asm("
    setq 1, %r1
    ld $start_addr, %r2
    syscall");
}

void _kill_process(int pid) {
    if(pid >= PROCESS_COUNT) {
        _panic(5);
    }

    if(_free_pid(pid) == -1) {
        _panic(6);
    }

    void*[] stack_pointers = process_table.stack_pointers;
    stack_pointers[pid] = NULL;
}

void _start_process(void* start_addr) {
    void*[] stack_pointers = process_table.stack_pointers;
    int i = 0;
    while(stack_pointers[i] != NULL) {
        i = i + 1;
    }

    if(i >= PROCESS_COUNT) {
        _panic(1); // no PID/slot available
    }

    // we change the current process just for malloc to have it.
    int cp = process_table.current_process;
    process_table.current_process = i;

    void* stack = _malloc(256) + 255;

    process_table.current_process = cp;

    // as a convention, we put on the stack the address of the first
    // instruction of the task (for "bootstraping" the processes)
    *((int*) stack) = (int)start_addr;

    int j;
    for(j=0; j < NB_SAVED_REGISTERS; j=j+1) {
        stack = stack - 1;
        *((int*) stack) = 0;
    }

    stack_pointers[i] = stack;
}

