asm("
    ba start

    // interrupt table
    .word pwm_handler
    .word null_handler
    .word null_handler
    .word null_handler
    .word rs232_handler_read
    .word null_handler
    .word null_handler

null_handler: reti
start:
    set 0x1FFF, %sp // stack at the end of the memory
    ba f_main
")

// global variables

// every N PWM-interruptions we do a context switch, this is the counter
int pwm_count;

#define PROCESS_COUNT 4

struct process_table_t {
    int process_count;
    int current_process;
    void*[PROCESS_COUNT] stack_pointers;
};

struct process_table_t* process_table;

// implementation of the context switch
asm("
pwm_handler:
    push %r1

    ld $pwm_count, %r1
    inccc %r1

    // do we do a context switch, or nothing ?
    cmp %r1, 10
    bge pwm_handler_do_it

    st %r1, $pwm_count
    pop %r1
    reti

    ////////////////////
    // context switch //
    ////////////////////

pwm_handler_do_it:
    xor %r1, %r1, %r1 // reset the counter
    st %r1, $pwm_count

    push %r2
    push %r3
    push %r4
    push %r5
    push %r6
    push %r7
    push %r8
    push %r9
    push %r10
    push %r11
    push %r12
    push %r13
    push %r14
    push %r15
    push %r16
    push %r17
    push %r18
    push %r19
    push %fp
    push %r28 // @ret

    ld $process_table, %r2
    ld [%r2], %r3 // %r3: nb_tasks
    ld [%r2 + 1], %r4 // %r4: current_task
    add %r4, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry

    // store the stack pointer
    st %sp, [%r5]

    // now it is stored, we can load the other task

    // current_task = (current_task + 1) % nb_tasks
    inccc %r4
    cmp %r4, %r3
    bl pwm_handler_afterreset
    xor %r4, %r4, %r4 // %r4 <- 0
pwm_handler_afterreset:

    st %r4, [%r2 + 1]

    add %r4, 2, %r5
    add %r5, %r2, %r5 // %r5: current task entry

    // We switch the stack now that everything is pop'ed
    ld [%r5], %sp

    pop %r28 // @ret
    pop %fp
    pop %r19
    pop %r18
    pop %r17
    pop %r16
    pop %r15
    pop %r14
    pop %r13
    pop %r12
    pop %r11
    pop %r10
    pop %r9
    pop %r8
    pop %r7
    pop %r6
    pop %r5
    pop %r4
    pop %r3
    pop %r2
    pop %r1
    reti
")

// MALLOC {{{

// used internally by the malloc
void *malloc_start;

// palkeo's malloc
// Very simple system : in block. Before each block we have a header.
// The last bit tell if the block is allocated or not.
// The rest is the size of the block (so we shift >> 1, and we have the size)

// get the nearest power of two that is bigger than the parameter.
int nbp2(int n)
{
    int s = n - 1;
    n = 1;
    while((bool)s)
    {
        s = s >> 1;
        n = n << 1;
    }
    return n;
}

void memcpy(void* source, void* destination, int size)
{
    int i;
    for(i = 0; i < size; i=i+1)
    {
        *((int*)destination + i) = *((int*)source + i);
    }
}

void* malloc(int size) {
    size = nbp2(size);

    int* c = (int*)malloc_start;
    while (
        (bool)(*c & 1)
     || (((*c >> 1) != size) && ((bool)*c))
    ) {
        c = c + (*c >> 1) + 1;
    }
    // c now points to an unused block header of the right size

    int bs = *c >> 1;
    if(bs == 0) { // end of the blocklist
        *c = (size << 1) + 1;
        *(c + size + 1) = 0;
    }
    else {
        // We could split the block here
        *c = *c | 1;
    }
    return (void*)c + 1;
}

int free(void* addr) {
    int* c = (int*)malloc_start;
    while (c < addr - 1) {
        c = c + (*c >> 1) + 1;
        if(*c == 0) {
            return -1; // the address is after the last allocated block...
        }
    }

    // can't find block or already freed
    if ((c != addr - 1) || ((*c & 1) == 0)) {
        return -1;
    }

    *c = *c & 0xFFFFFFFE;
    if (*((int*) (*c >> 1) + 1) == 0) {
        *c = 0; // if it was the last block...
    }

    // We could merge with the next block if it is empty here
    return 0;
}

void* realloc(void* addr, int new_size)
{
    new_size = nbp2(new_size);

    // taken from the free implementation
    // ---
    int* c = (int*)malloc_start;
    while (c < addr - 1) {
        c = c + (*c >> 1) + 1;
        if(*c == 0) {
            return (void*)-1; // the address is after the last allocated block...
        }
    }
    // can't find block or already freed
    if ((c != addr - 1) || ((*c & 1) == 0)) {
        return (void*)-1;
    }
    // ---

    // already the good size
    if((*c >> 1) >= new_size)
    {
        return addr;
    }
    
    // here we will need to allocate a new block and copy it.
    void* new_addr = malloc(new_size);
    memcpy(addr, new_addr, *c >> 1);
    if(free(addr) == -1)
    {
        return (void*)-1;
    }
    return new_addr;
}

// MALLOC }}}

// RS-232 {{{

char[256] rs232_read_buf;
int rs232_read_buf_begin;
int rs232_read_buf_end;
asm("
rs232_handler_read:
    push %r1
    push %r2
    push %r3

    push %r28
    call f_rs232_handler_read
    pop %r28

    pop %r3
    pop %r2
    pop %r1
    reti
")

export void rs232_handler_read() {
    rs232_read_buf[rs232_read_buf_end] = *((char*)0xD0000000);

    rs232_read_buf_end = (rs232_read_buf_end+1) & 0xff;

    rs232_read_buf_begin = rs232_read_buf_begin
                         + (int)(rs232_read_buf_begin == rs232_read_buf_end);
}

char getc() {
    if (rs232_read_buf_begin == rs232_read_buf_end) {
        return (char)-1;
    }
    else {
        char result = rs232_read_buf[rs232_read_buf_begin];
        rs232_read_buf_begin = (rs232_read_buf_begin+1) & 0xff;
        return result;
    }
}

char* strcpy(char* dest, char* src)
{
    int i;

    for (i = 0; src[i] != '\0'; i = i+1) {
        dest[i] = src[i];
    }

    return dest;
}

char* getline() {
    int i;
    char c = (char)-1;
    int size = 32;
    char* buf = (char*)malloc(size);
    char* new_buf;

    for (i = 0; c != '\n' && c != '\0'; i = i+1) {
        c = getc();

        if ((int)c == -1) {
            continue;
        }

        if (i == size) {
            size = size*2;
            buf = (char*)realloc((void*)buf, size);
        }

        buf[i] = c;
    }

    if (i == size) {
        size = size*2;
        buf = (char*)realloc((void*)buf, size);
    }

    buf[i] = '\0';

    return buf;
}

int strlen(char* str) {
    int i = 0;
    while (str[i] != '\0') {
        i = i+1;
    }
    return i;
}

void putc(char c) {
    *((char*)0xD0000001) = c;

    int i;
    for(i = 0; i < 500; i=i+1) {
        // wait for the byte to be sent
    }
}

void write(char* string) {
    int i;
    for(i = 0; (bool)string[i]; i=i+1) {
        putc(string[i]);
    }
}

// convert an int to an hexadecimal string like 0xDEADBEEF
void dtoa(int number, char* string) {
    string[0] = '0';
    string[1] = 'x';
    int i = 2;
    int n = number;
    while ((bool)n) {
        n = n >> 4;
        i = i + 1;
    }

    if (i == 2) {
        i = 3; // if number == 0, we print a zero after 0x.
    }

    // i contains the number of chars
    string[i+1] = (char)0;
    while (i > 2) {
        n = number & 0xF;
        if (n < 10) {
            n = n + (int)'0';
        }
        else {
            n = n - 10 + (int)'A';
        }
        i = i - 1;
        string[i] = (char)n;
        number = number >> 4;
    }
}

// RS-232 }}}

// TASKS {{{

export int task1() {
    int *rs232 = (int*) 0xD0000001;
    while (true) {
        /*
        int got = (int)getc();
        if (got != -1) {
            *rs232 = got;
        }
        */
    }
}

export int task2() {
    int *ssegs = (int*) 0xA0000000;
    while (true) {
        *(ssegs + 1) = 0b1111;
        *ssegs = rs232_read_buf_end-rs232_read_buf_begin;
    }
}

#include "shell.moc"

export int task3() {
    while (true) {
        char* line = getline();
        shell(line);
        free((void*)line);
    }
}

export int task4() {
    int *ssegs = (int*) 0xA0000000;
    while (true) {
        void* i = malloc(2);
        *((int*)i) = 7;
        *((int*)i+1) = 6;
        *ssegs = (int)i;
        free(i);
        i = malloc(10);
        void* j = malloc(10);
        free(i);
        void* k = malloc(5);
        free(j);
        free(k);
    }
}

// TASKS }}}

int main() {
    pwm_count = 0;
    // /!\ Should be big enough not to overwrite the code !
    malloc_start = (void*)0x500;
    *((int*)malloc_start) = 0;

    // process table
    process_table = (struct process_table_t*)malloc(sizeof(struct process_table_t));
    process_table->process_count = PROCESS_COUNT;
    process_table->current_process = 0;

    void*[PROCESS_COUNT] tasks;
    tasks[0] = task1;
    tasks[1] = task2;
    tasks[2] = task3;
    tasks[3] = task4;

    // initialize all processes
    void*[] stack_pointers = process_table->stack_pointers;
    int i;
    int j;

    for (i=0; i < PROCESS_COUNT; i=i+1) {
        // we build the stack for the process i
        void* stack = malloc(256) + 255;

        // as a convention, we put on the stack the address of the first
        // instruction of the task (for "bootstraping" the processes)
        *((int*) stack) = (int)tasks[i];

        if (i > 0) {
            // fill the end of the stack of the processes that are waiting: they will
            // be restored by the scheduler!
            // we push %psr, %r1..%r19, %fp, %r28 (ret)
            for (j=0; j < 22; j=j+1) {
                stack = stack - 1;
                *((int*) stack) = 0;
            }
        }

        stack_pointers[i] = stack;
    }

    // PWM rising edge every milliseconds
    *((int*)0xC0000000) = 195; // P
    *((int*)0xC0000001) = 98; // N

    // first task: loads its stack and runs it
    void* sp = stack_pointers[0];
    asm("
        ld $sp, %sp
        ld [%sp], %pc
    ");
}

